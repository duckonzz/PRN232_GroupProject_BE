using GenderHealthCare.Contract.Repositories.Interfaces;
using GenderHealthCare.Contract.Services.Interfaces;
using GenderHealthCare.Core.Constants;
using GenderHealthCare.Core.Enums;
using GenderHealthCare.Core.Exceptions;
using GenderHealthCare.Core.Helpers;
using GenderHealthCare.Entity;
using GenderHealthCare.ModelViews.CycleTrackingModels;
using GenderHealthCare.Services.Mapping;
using Microsoft.AspNetCore.Http;
using Microsoft.EntityFrameworkCore;

namespace GenderHealthCare.Services.Services
{
    public class CycleTrackingService : ICycleTrackingService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IAuthenticationService _authenticationService;

        public CycleTrackingService(IUnitOfWork unitOfWork, IAuthenticationService authenticationService)
        {
            _unitOfWork = unitOfWork;
            _authenticationService = authenticationService;
        }

        public async Task<CycleTrackingResponse> CreateCycleAsync(string userId, CycleTrackingRequest request)
        {
            await ValidateCycleTrackingOn(userId);

            var cycleRepo = _unitOfWork.GetRepository<ReproductiveCycle>();

            // Lấy chu kỳ mới nhất chưa bị xóa
            var latestCycle = await cycleRepo.Entities
                .Where(c => c.UserId == userId && !c.DeletedTime.HasValue)
                .OrderByDescending(c => c.StartDate)
                .FirstOrDefaultAsync();

            var cycleLength = request.CycleLength ?? latestCycle?.CycleLength ?? 28;
            var periodLength = request.PeriodLength ?? latestCycle?.PeriodLength ?? 5;

            var requestStartDate = request.StartDate.Date;

            if (requestStartDate > CoreHelper.SystemTimeNow.Date)
            {
                throw new ErrorException(StatusCodes.Status400BadRequest, ResponseCodeConstants.BADREQUEST,
                    "Cannot create a cycle with a start date in the future");
            }

            // Tìm xem có cycle auto nào trùng start date không
            var existingCycle = await cycleRepo.Entities
                .Where(c => c.UserId == userId && c.StartDate.Date == requestStartDate && !c.DeletedTime.HasValue)
                .FirstOrDefaultAsync();

            if (existingCycle != null)
            {
                if (!existingCycle.IsAutoGenerated)
                {
                    throw new ErrorException(StatusCodes.Status400BadRequest, ResponseCodeConstants.BADREQUEST,
                        "This cycle was created manually and cannot be overwritten");
                }

                // Cho phép override nếu là chu kỳ tự động
                existingCycle.CycleLength = cycleLength;
                existingCycle.PeriodLength = periodLength;
                existingCycle.EndDate = requestStartDate.AddDays(periodLength - 1);
                existingCycle.Notes = request.Notes ?? existingCycle.Notes;
                existingCycle.IsAutoGenerated = false;
                existingCycle.LastUpdatedTime = CoreHelper.SystemTimeNow;

                cycleRepo.Update(existingCycle);
                await _unitOfWork.SaveAsync();

                // Xóa notification cũ và tạo mới
                var notifyRepo = _unitOfWork.GetRepository<CycleNotification>();
                var oldNotifies = await notifyRepo.Entities
                    .Where(n => n.ReproductiveCycleId == existingCycle.Id && !n.IsSent && !n.DeletedTime.HasValue)
                    .ToListAsync();

                oldNotifies.ForEach(n => n.DeletedTime = CoreHelper.SystemTimeNow);
                notifyRepo.UpdateRange(oldNotifies);
                await _unitOfWork.SaveAsync();

                await GenerateCycleNotificationsAsync(userId, existingCycle);

                return existingCycle.ToCycleTrackingDto();
            }

            if (latestCycle != null && requestStartDate <= latestCycle.EndDate)
            {
                throw new ErrorException(StatusCodes.Status400BadRequest, ResponseCodeConstants.BADREQUEST,
                    "Start date must be after the previous cycle's end date");
            }

            var newCycle = new ReproductiveCycle
            {
                UserId = userId,
                StartDate = requestStartDate,
                EndDate = requestStartDate.AddDays(periodLength - 1),
                CycleLength = cycleLength,
                PeriodLength = periodLength,
                Notes = request.Notes,
            };

            await cycleRepo.InsertAsync(newCycle);
            await _unitOfWork.SaveAsync();

            await GenerateCycleNotificationsAsync(userId, newCycle);

            return newCycle.ToCycleTrackingDto();
        }


        public async Task DeleteCycleAsync(string cycleId, string userId)
        {
            await ValidateCycleTrackingOn(userId);
            var cycleRepo = _unitOfWork.GetRepository<ReproductiveCycle>();
            var cycle = await cycleRepo.Entities
                .FirstOrDefaultAsync(c => c.Id == cycleId && c.UserId == userId)
                ?? throw new Exception("Cycle not found");

            cycle.DeletedTime = CoreHelper.SystemTimeNow;

            cycleRepo.Update(cycle);
            await _unitOfWork.SaveAsync();
        }

        public async Task<CycleTrackingResponse> GetCycleByIdAsync(string cycleId, string userId)
        {
            await ValidateCycleTrackingOn(userId);
            var cycleRepo = _unitOfWork.GetRepository<ReproductiveCycle>();
            var cycle = await cycleRepo.Entities
                .FirstOrDefaultAsync(c => c.Id == cycleId && c.UserId == userId && !c.DeletedTime.HasValue)
                ?? throw new ErrorException(StatusCodes.Status404NotFound, ResponseCodeConstants.NOT_FOUND, "Cycle not found");

            return cycle.ToCycleTrackingDto();
        }

        public async Task<IEnumerable<CycleTrackingResponse>> GetCyclesAsync(string userId)
        {
            var cycleRepo = _unitOfWork.GetRepository<ReproductiveCycle>();
            var cycles = await cycleRepo.Entities
                .Where(c => c.UserId == userId)
                .OrderByDescending(c => c.StartDate)
                .ToListAsync();

            return cycles.ToCycleTrackingDtoList();
        }

        public async Task UpdateUserCycleTrackingAsync(string userId, bool isEnabled)
        {
            var user = await _unitOfWork.GetRepository<User>().Entities.FirstOrDefaultAsync(u => u.Id == userId && !u.DeletedTime.HasValue)
                ?? throw new ErrorException(StatusCodes.Status404NotFound, ResponseCodeConstants.NOT_FOUND, "User not found");

            if (!isEnabled)
            {
                var notifyRepo = _unitOfWork.GetRepository<CycleNotification>();
                var pendingNotifications = await notifyRepo.Entities
                    .Where(n => n.UserId == userId && !n.IsSent && !n.DeletedTime.HasValue)
                    .ToListAsync();

                pendingNotifications.ForEach(n => n.DeletedTime = CoreHelper.SystemTimeNow);

                notifyRepo.UpdateRange(pendingNotifications);
            }

            user.IsCycleTrackingOn = isEnabled == true;
            user.LastUpdatedTime = CoreHelper.SystemTimeNow;

            _unitOfWork.GetRepository<User>().Update(user);
            await _unitOfWork.SaveAsync();
        }

        public async Task GenerateCycleNotificationsAsync(string userId, ReproductiveCycle cycle)
        {
            var notifyRepo = _unitOfWork.GetRepository<CycleNotification>();
            var notifications = new List<CycleNotification>();

            var upcomingPeriodDate = cycle.StartDate.AddDays(cycle.CycleLength - 3);
            var ovulationDate = cycle.StartDate.AddDays(cycle.CycleLength - 14);
            var fertileWindowStart = ovulationDate.AddDays(-3);
            var fertileWindowEnd = ovulationDate.AddDays(1);

            notifications.Add(new CycleNotification
            {
                UserId = userId,
                ReproductiveCycleId = cycle.Id,
                NotificationType = NotificationType.UpcomingPeriod.ToString(),
                NotificationDate = upcomingPeriodDate,
                Message = "Kỳ kinh tiếp theo sẽ bắt đầu trong 3 ngày nữa",
            });

            notifications.Add(new CycleNotification
            {
                UserId = userId,
                ReproductiveCycleId = cycle.Id,
                NotificationType = NotificationType.Ovulation.ToString(),
                NotificationDate = ovulationDate,
                Message = "Hôm nay là ngày rụng trứng của bạn",
            });

            for (var date = fertileWindowStart; date <= fertileWindowEnd; date = date.AddDays(1))
            {
                notifications.Add(new CycleNotification
                {
                    UserId = userId,
                    ReproductiveCycleId = cycle.Id,
                    NotificationType = NotificationType.FertileWindow.ToString(),
                    NotificationDate = date,
                    Message = $"Hôm nay ({date:dd/MM}) là ngày dễ thụ thai của bạn"
                });
            }

            await notifyRepo.InsertRangeAsync(notifications);
            await _unitOfWork.SaveAsync();
        }

        #region Shared private methods
        private async Task ValidateCycleTrackingOn(string userId)
        {
            var user = await _authenticationService.GetUserByIdAsync(userId);
            if (!user.IsCycleTrackingOn)
                throw new ErrorException(StatusCodes.Status403Forbidden, ResponseCodeConstants.FORBIDDEN, "Cycle tracking is disabled for this user.");
        }
        #endregion
    }
}
